"""Utilities for convolving families of kernels with data.

Author: Ankit N. Khambhati
Adapted from: https://github.com/pennmem/ptsa_new/blob/master/ptsa/wavelet.py
Last Updated: 2023/08/23
"""

from typing import Any

import numpy as np
import numpy.typing as npt
import pyfftw
import scipy.fftpack


def _reserve_fftw_mem(
    kernel_len: int, signal_len: int, n_kernel: int, threads: int = 6
) -> tuple[Any, Any]:
    """Helper function to pre-allocate memory for pyfftw."""
    a = pyfftw.empty_aligned((kernel_len + signal_len, n_kernel), dtype=complex)
    fft = pyfftw.builders.fft(a, axis=0, threads=threads)
    ifft = pyfftw.builders.ifft(a, axis=0, threads=threads)

    return fft, ifft


def fconv(
    kernel: npt.NDArray[np.complex_],
    signal: npt.NDArray[np.float_],
    fftpack: Any = scipy.fftpack,
    boundary: Any = None,
    interp_nan: bool = True,
) -> npt.NDArray[np.complex_]:
    """Convolve kernel bank with multidimensional signals using FFT.

    Parameters
    ----------
    kernel: np.ndarray, shape: [n_sample_1, n_kernel]
        Array of kernels (generated by `family` module)
    signal: np.ndarray, shape: [n_sample_2, n_signal]
        Multidimensional signal array (must be two dimensional)
    fftpack: {scipy.fftpack, pyfftw.builders}
        Function handles to a routine that calls fft/ifft.
    boundary: {None, 'mirror'}
        Specifies how to handle the boundary of the signal.
    interp_nan: bool
        Specifies whether to return interpolated result or to add
        NaNs back into the convolved signal.

    Returns
    -------
    arr_conv: np.ndarray, shape: [n_sample_2, n_kernel, n_signal]
    """
    # Convert to complex types
    kernel = np.asarray(kernel, dtype=complex)
    signal = np.asarray(signal, dtype=complex)

    # get the number of signals and samples in each input
    n_sample_1, n_kernel = kernel.shape
    n_sample_2, n_signal = signal.shape
    n_s = n_sample_1 + n_sample_2

    # Handle boundary case
    if boundary == "mirror":
        signal_lead = signal[:n_sample_1, :][::-1, :]
        signal_lag = signal[-n_sample_1:, :][::-1, :]
        signal = np.concatenate((signal_lead, signal, signal_lag))
        n_sample_2 = signal.shape[0]
        n_s = n_sample_1 + n_sample_2

    # Handle NaNs and Infs
    mask_nan = ~np.isfinite(signal)
    signal[mask_nan] = 0

    # Pre-allocate array
    arr_conv = np.zeros((n_sample_2, n_kernel, n_signal), dtype=complex)

    # Determine the fft/ifft solvers
    fft_type = fftpack.__name__
    if fft_type == "pyfftw.builders":
        fft, ifft = _reserve_fftw_mem(n_sample_1, n_sample_2, n_kernel)
    else:
        fft, ifft = (fftpack.fft, fftpack.ifft)

    # Pre-compute `FFT Kernel`
    if fft_type == "pyfftw.builders":
        fft.input_array[...] = 0
        fft.input_array[centered(n_s, n_sample_1), :] = kernel[:, :]
        fft.input_array[...] = np.fft.ifftshift(fft.input_array, axes=0)
        fft_kernel = fft().copy()
    else:
        big_arr = np.zeros((n_s, n_kernel), dtype=complex)
        big_arr[centered(n_s, n_sample_1), :] = kernel[:, :]
        big_arr = np.fft.ifftshift(big_arr, axes=0)
        fft_kernel = fft(big_arr, axis=0)

    # Pre-compute `FFT Energy`
    if fft_type == "pyfftw.builders":
        fft.input_array[...] = 0
        fft.input_array[centered(n_s, n_sample_1), :] = np.abs(kernel**2)
        fft.input_array[...] = np.fft.ifftshift(fft.input_array, axes=0)
        fft_energy = fft().copy()
    else:
        big_arr = np.zeros((n_s, n_kernel), dtype=complex)
        big_arr[centered(n_s, n_sample_1), :] = np.abs(kernel**2)
        big_arr = np.fft.ifftshift(big_arr, axes=0)
        fft_energy = fft(big_arr, axis=0)

    # Iterate over each signal dimension
    for s_i in range(n_signal):
        # Compute signal FFT
        if fft_type == "pyfftw.builders":
            fft.input_array[...] = 0
            fft.input_array[centered(n_s, n_sample_2), :] = signal[:, s_i].reshape(
                -1, 1
            )
            fft_signal = fft()
        else:
            big_arr = np.zeros((n_s, n_kernel), dtype=complex)
            big_arr[centered(n_s, n_sample_2), :] = signal[:, s_i].reshape(-1, 1)
            fft_signal = fft(big_arr, axis=0)

        # Convolve main signal with kernel
        fft_sigkern = fft_signal * fft_kernel

        # Compute main_kernel iFFT
        if fft_type == "pyfftw.builders":
            ifft.input_array[:, :] = fft_sigkern[...]
            ifft_sigkern = ifft().copy()
        else:
            ifft_sigkern = ifft(fft_sigkern, axis=0)

        # Compute mask FFT
        if fft_type == "pyfftw.builders":
            fft.input_array[...] = 0
            fft.input_array[centered(n_s, n_sample_2), :] = np.asarray(
                1.0 - mask_nan[:, s_i], dtype=complex
            ).reshape(-1, 1)
            fft_missing = fft()
        else:
            big_arr = np.zeros((n_s, n_kernel), dtype=complex)
            big_arr[centered(n_s, n_sample_2), :] = (1.0 - mask_nan[:, s_i]).reshape(
                -1, 1
            )
            fft_missing = fft(big_arr, axis=0)

        # Convolve mask signal with kernel
        fft_missnrg = fft_missing * fft_energy

        # Compute miss_energy iFFT
        if fft_type == "pyfftw.builders":
            ifft.input_array[:, :] = fft_missnrg
            ifft_missnrg = np.sqrt(ifft())
        else:
            ifft_missnrg = np.sqrt(ifft(fft_missnrg, axis=0))

        # Final inverse transform gives the convolution,
        # normalized by segment of valid kernel (non-NaN portion)
        sigkern_missnrg = ifft_sigkern / ifft_missnrg
        sigkern_missnrg[ifft_missnrg < (10 * np.finfo(ifft_missnrg.dtype).eps)] = 0.0

        # Clip the convolved signal to the signal length
        arr_conv[:, :, s_i] = sigkern_missnrg[centered(n_s, n_sample_2), :]

        # Put NaN back
        if not interp_nan:
            arr_conv[mask_nan[:, s_i], :, s_i] = np.nan

    # Remove the mirrored buffer
    if boundary == "mirror":
        arr_conv = arr_conv[n_sample_1:-n_sample_1, ...]

    return arr_conv


def centered(curr_size: int, new_size: int) -> slice:
    """Use with convolution, return center indices for an array of a specific len.

    Parameters
    ----------
    curr_size: int
        Length of dimension to truncate in the current array.
    new_size: int
        Intended length of the dimension to truncate in the new array.

    Returns
    -------
    ind: slice
        Indices to excise the center portion along one dimension
        of the current array.
    """
    curr_size = int(curr_size)
    new_size = int(new_size)

    center = curr_size - (curr_size + 1) // 2
    return slice(center - (new_size) // 2, center + (new_size + 1) // 2)
