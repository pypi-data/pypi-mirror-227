from collections import OrderedDict
import datetime
import json as json
import oauth2client.client # type: ignore
import re as re
from typing import List, Any, Optional, TypeVar, Iterator, Type
from typing_extensions import Self
from _typeshed import Incomplete
from decimal import Decimal
from docassemble.base import DA as DA
from docassemble.base.error import DAValidationError as DAValidationError, DAWebError as DAWebError
from docassemble.base.file_docx import include_docx_template as include_docx_template
from docassemble.base.functions import action_argument as action_argument, action_arguments as action_arguments, action_menu_item as action_menu_item, add_separators as add_separators, all_variables as all_variables, alpha as alpha, background_action as background_action, background_error_action as background_error_action, background_response as background_response, background_response_action as background_response_action, bold as bold, capitalize as capitalize, chat_partners_available as chat_partners_available, comma_and_list as comma_and_list, comma_list as comma_list, command as command, countries_list as countries_list, country_name as country_name, create_session as create_session, create_user as create_user, currency as currency, currency_symbol as currency_symbol, CustomDataType as CustomDataType, decode_name as decode_name, define as define, defined as defined, delete_record as delete_record, device as device, dispatch as dispatch, encode_name as encode_name, fix_punctuation as fix_punctuation, force_ask as force_ask, force_gather as force_gather, forget_result_of as forget_result_of, from_b64_json as from_b64_json, get_chat_log as get_chat_log, get_config as get_config, get_country as get_country, get_default_timezone as get_default_timezone, get_dialect as get_dialect, get_emails as get_emails, get_info as get_info, get_language as get_language, get_locale as get_locale, get_progress as get_progress, get_question_data as get_question_data, get_session_variables as get_session_variables, get_user_info as get_user_info, get_user_list as get_user_list, get_user_secret as get_user_secret, get_voice as get_voice, go_back_in_session as go_back_in_session, indefinite_article as indefinite_article, indent as indent, interface as interface, interview_email as interview_email, interview_list as interview_list, interview_menu as interview_menu, interview_url as interview_url, interview_url_action as interview_url_action, interview_url_action_as_qr as interview_url_action_as_qr, interview_url_as_qr as interview_url_as_qr, invalidate as invalidate, italic as italic, item_label as item_label, json_response as json_response, language_from_browser as language_from_browser, language_name as language_name, location_known as location_known, location_returned as location_returned, log as log, manage_privileges as manage_privileges, message as message, name_suffix as name_suffix, need as need, nice_number as nice_number, noun_plural as noun_plural, noun_singular as noun_singular, noyes as noyes, ordinal as ordinal, ordinal_number as ordinal_number, period_list as period_list, phone_number_formatted as phone_number_formatted, phone_number_in_e164 as phone_number_in_e164, phone_number_is_valid as phone_number_is_valid, phone_number_part as phone_number_part, plain as plain, prevent_going_back as prevent_going_back, process_action as process_action, qr_code as qr_code, quantity_noun as quantity_noun, quote_paragraphs as quote_paragraphs, raw as raw, re_run_logic as re_run_logic, read_records as read_records, reconsider as reconsider, redact as redact, referring_url as referring_url, response as response, roman as roman, run_action_in_session as run_action_in_session, server_capabilities as server_capabilities, session_tags as session_tags, set_country as set_country, set_info as set_info, set_language as set_language, set_live_help_status as set_live_help_status, set_locale as set_locale, set_parts as set_parts, set_progress as set_progress, set_save_status as set_save_status, set_session_variables as set_session_variables, set_title as set_title, set_user_info as set_user_info, set_variables as set_variables, showif as showif, showifdef as showifdef, single_paragraph as single_paragraph, single_to_double_newlines as single_to_double_newlines, space_to_underscore as space_to_underscore, split as split, state_name as state_name, states_list as states_list, static_image as static_image, store_variables_snapshot as store_variables_snapshot, subdivision_type as subdivision_type, title_case as title_case, undefine as undefine, update_terms as update_terms, url_action as url_action, url_of as url_of, user_has_privilege as user_has_privilege, user_info as user_info, user_lat_lon as user_lat_lon, user_logged_in as user_logged_in, user_privileges as user_privileges, us as us, value as value, variables_as_json as variables_as_json, verb_past as verb_past, verb_present as verb_present, verbatim as verbatim, word as word, write_record as write_record, yesno as yesno, this_thread as this_thread, update_locale as update_locale
from itertools import chain as chain

capitalize_func = capitalize

__all__: List[str] = [
    'Address', 'Asset', 'ChildList', 'City', 'DA', 'DABreadCrumbs', 'DACloudStorage', 'DAContext', 'DADict', 'DAEmail', 'DAEmailRecipient', 'DAEmailRecipientList', 'DAEmpty', 'DAFile', 'DAFileCollection', 'DAFileList', 'DAGlobal', 'DAGoogleAPI', 'DALink', 'DAList', 'DAOAuth', 'DAObject', 'DAOrderedDict', 'DARedis', 'DASet', 'DAStaticFile', 'DAStore', 'DATemplate', 'DAValidationError', 'DAWeb', 'DAWebError', 'Event', 'Expense', 'FinancialList', 'Income', 'Individual', 'IndividualName', 'LatitudeLongitude', 'MachineLearningEntry', 'Name', 'OfficeList', 'Organization', 'PeriodicFinancialList', 'PeriodicValue', 'Person', 'RandomForestMachineLearner', 'RelationshipTree', 'RoleChangeTracker', 'SVMMachineLearner', 'SimpleTextMachineLearner', 'Thing', 'Value', 'action_argument', 'action_arguments', 'action_button_html', 'action_menu_item', 'add_separators', 'all_variables', 'alpha', 'as_datetime', 'assemble_docx', 'background_action', 'background_error_action', 'background_response', 'background_response_action', 'bold', 'capitalize', 'chain', 'chat_partners_available', 'clear_explanations', 'comma_and_list', 'comma_list', 'command', 'countries_list', 'country_name', 'create_session', 'create_user', 'currency', 'currency_symbol', 'current_datetime', 'date_difference', 'date_interval', 'day_of', 'decode_name', 'define', 'defined', 'delete_record', 'device', 'dispatch', 'docx_concatenate', 'dow_of', 'encode_name', 'explain', 'fix_punctuation', 'force_ask', 'force_gather', 'forget_result_of', 'format_date', 'format_datetime', 'format_time', 'from_b64_json', 'get_chat_log', 'get_config', 'get_country', 'get_default_timezone', 'get_dialect', 'get_emails', 'get_info', 'get_language', 'get_locale', 'get_progress', 'get_question_data', 'get_session_variables', 'get_sms_session', 'get_status', 'get_user_info', 'get_user_list', 'get_user_secret', 'get_voice', 'go_back_in_session', 'include_docx_template', 'indefinite_article', 'indent', 'initiate_sms_session', 'interface', 'interview_email', 'interview_list', 'interview_menu', 'interview_url', 'interview_url_action', 'interview_url_action_as_qr', 'interview_url_as_qr', 'invalidate', 'iso_country', 'italic', 'item_label', 'json', 'json_response', 'language_from_browser', 'language_name', 'last_access_days', 'last_access_delta', 'last_access_hours', 'last_access_minutes', 'last_access_time', 'location_known', 'location_returned', 'log', 'logic_explanation', 'manage_privileges', 'map_of', 'mark_task_as_performed', 'message', 'month_of', 'name_suffix', 'need', 'nice_number', 'noun_plural', 'noun_singular', 'noyes', 'objects_from_file', 'ocr_file', 'ocr_file_in_background', 'ordinal', 'ordinal_number', 'overlay_pdf', 'path_and_mimetype', 'pdf_concatenate', 'period_list', 'phone_number_formatted', 'phone_number_in_e164', 'phone_number_is_valid', 'phone_number_part', 'plain', 'prevent_going_back', 'process_action', 'qr_code', 'quantity_noun', 'quote_paragraphs', 'raw', 're', 're_run_logic', 'read_qr', 'read_records', 'reconsider', 'redact', 'referring_url', 'response', 'retrieve_stashed_data', 'returning_user', 'roman', 'run_action_in_session', 'run_python_module', 'selections', 'send_email', 'send_fax', 'send_sms', 'server_capabilities', 'session_tags', 'set_country', 'set_info', 'set_language', 'set_live_help_status', 'set_locale', 'set_parts', 'set_progress', 'set_save_status', 'set_session_variables', 'set_status', 'set_task_counter', 'set_title', 'set_user_info', 'set_variables', 'showif', 'showifdef', 'single_paragraph', 'single_to_double_newlines', 'space_to_underscore', 'split', 'start_time', 'stash_data', 'state_name', 'states_list', 'static_image', 'store_variables_snapshot', 'subdivision_type', 'task_not_yet_performed', 'task_performed', 'terminate_sms_session', 'times_task_performed', 'timezone_list', 'title_case', 'today', 'transform_json_variables', 'undefine', 'update_terms', 'update_locale', 'url_action', 'url_ask', 'url_of', 'us', 'user_has_privilege', 'user_info', 'user_lat_lon', 'user_logged_in', 'user_privileges', 'validation_error', 'value', 'variables_as_json', 'verb_past', 'verb_present', 'verbatim', 'word', 'write_record', 'year_of', 'yesno', 'zip_file'
]

_T = TypeVar('_T')

class DAEmpty:
    # This is a str, but mypy can't handle using a type str as a object attribute.
    str: Incomplete
    def __init__(self, *pargs, **kwargs) -> None: ...
    def __getattr__(self, thename): ...
    def __str__(self) -> str: ...
    def __dir__(self) -> list: ...
    def __contains__(self, item) -> bool: ...
    def __iter__(self): ...
    def __len__(self) -> int: ...
    def __reversed__(self) -> list: ...
    def __getitem__(self, index): ...
    def __setitem__(self, index, val) -> None: ...
    def __delitem__(self, index) -> None: ...
    def __call__(self, *pargs, **kwargs): ...
    def __repr__(self): ...
    def __add__(self, other: _T) -> _T: ...
    def __sub__(self, other: _T) -> _T: ...
    def __mul__(self, other: _T) -> _T: ...
    def __floordiv__(self, other: _T) -> _T: ...
    def __mod__(self, other: _T) -> _T: ...
    def __divmod__(self, other: _T) -> _T: ...
    def __pow__(self, other: _T) -> _T: ...
    def __lshift__(self, other: _T) -> _T: ...
    def __rshift__(self, other: _T) -> _T: ...
    def __and__(self, other: _T) -> _T: ...
    def __xor__(self, other: _T) -> _T: ...
    def __or__(self, other: _T) -> _T: ...
    def __div__(self, other: _T) -> _T: ...
    def __truediv__(self, other: _T) -> _T: ...
    def __radd__(self, other: _T) -> _T: ...
    def __rsub__(self, other: _T) -> _T: ...
    def __rmul__(self, other: _T) -> _T: ...
    def __rdiv__(self, other: _T) -> _T: ...
    def __rtruediv__(self, other: _T) -> _T: ...
    def __rfloordiv__(self, other: _T) -> _T: ...
    def __rmod__(self, other: _T) -> _T: ...
    def __rdivmod__(self, other: _T) -> _T: ...
    def __rpow__(self, other: _T) -> _T: ...
    def __rlshift__(self, other: _T) -> _T: ...
    def __rrshift__(self, other: _T) -> _T: ...
    def __rand__(self, other: _T) -> _T: ...
    def __ror__(self, other: _T) -> _T: ...
    def __neg__(self): ...
    def __pos__(self): ...
    def __abs__(self): ...
    def __invert__(self): ...
    def __complex__(self) -> complex: ...
    def __int__(self) -> int: ...
    def __float__(self) -> float: ...
    def __oct__(self): ...
    def __hex__(self): ...
    def __index__(self) -> int: ...
    def __le__(self, other) -> bool: ...
    def __ge__(self, other) -> bool: ...
    def __gt__(self, other) -> bool: ...
    def __lt__(self, other) -> bool: ...
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def __hash__(self): ...

class DAObjectPlusParameters: ...

class DAObject:
    def init(self, *pargs, **kwargs) -> None: ...
    @classmethod
    def using(cls, **kwargs): ...
    has_nonrandom_instance_name: bool
    instanceName: str
    attrList: list
    def __init__(self, *pargs, **kwargs) -> None: ...
    def _set_instance_name_for_function(self): ...
    def _set_instance_name_for_method(self): ...
    def attr_name(self, attr) -> str: ...
    def delattr(self, *pargs) -> None: ...
    def invalidate_attr(self, *pargs) -> None: ...
    def getattr_fresh(self, attr): ...
    def is_peer_relation(self, target, relationship_type, tree) -> bool: ...
    def is_relation(self, target, relationship_type, tree, self_is: str = ..., filter_by: dict | None = ...) -> bool: ...
    def get_relation(self, relationship_type, tree, self_is: str = ..., create: bool = ..., object_type: Incomplete | None = ..., complete_attribute: Incomplete | None = ..., rel_filter_by: Incomplete | None = ..., filter_by: Incomplete | None = ..., count: int = ...): ...
    def get_peer_relation(self, relationship_type, tree, create: bool = ..., object_type: Incomplete | None = ..., complete_attribute: Incomplete | None = ..., rel_filter_by: Incomplete | None = ..., filter_by: Incomplete | None = ..., count: int = ...): ...
    def set_peer_relationship(self, target, relationship_type, tree, replace: bool = ...): ...
    def set_relationship(self, target, relationship_type, self_is, tree, replace: bool = ...): ...
    def fix_instance_name(self, old_instance_name, new_instance_name) -> None: ...
    def set_instance_name(self, thename) -> None: ...
    def set_random_instance_name(self) -> None: ...
    def copy_shallow(self, thename) -> Self: ...
    def copy_deep(self, thename) -> Self: ...
    def _set_instance_name_recursively(self, thename, matching: Incomplete | None = ...) -> None: ...
    gathered: bool
    revisit: bool
    def _mark_as_gathered_recursively(self) -> None: ...
    def _reset_gathered_recursively(self) -> None: ...
    def _map_info(self) -> Optional[Any]: ...
    def __getattr__(self, thename): ...
    def object_name(self, **kwargs): ...
    def as_serializable(self): ...
    def object_possessive(self, target, **kwargs): ...
    def initializeAttribute(self, *pargs, **kwargs): ...
    def reInitializeAttribute(self, *pargs, **kwargs): ...
    def attribute_defined(self, name): ...
    def attr(self, name) -> Optional[Any]: ...
    def __str__(self): ...
    def __dir__(self): ...
    def pronoun_possessive(self, target, **kwargs): ...
    def pronoun(self, **kwargs): ...
    def alternative(self, *pargs, **kwargs): ...
    def pronoun_objective(self, **kwargs): ...
    def pronoun_subjective(self, **kwargs): ...
    def __setattr__(self, key, the_value) -> None: ...
    def __le__(self, other) -> bool: ...
    def __ge__(self, other) -> bool: ...
    def __gt__(self, other) -> bool: ...
    def __lt__(self, other) -> bool: ...
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def __hash__(self): ...

class DACatchAll(DAObject):
    def data_type_guess(self): ...
    context: str
    def __str__(self): ...
    def __dir__(self): ...
    operand: Incomplete
    def __contains__(self, item) -> bool: ...
    def __iter__(self): ...
    def __len__(self) -> int: ...
    def __reversed__(self): ...
    def __getitem__(self, index): ...
    def __repr__(self): ...
    def __add__(self, other): ...
    def __sub__(self, other): ...
    def __mul__(self, other): ...
    def __floordiv__(self, other): ...
    def __mod__(self, other): ...
    def __divmod__(self, other): ...
    def __pow__(self, other): ...
    def __lshift__(self, other): ...
    def __rshift__(self, other): ...
    def __and__(self, other): ...
    def __xor__(self, other): ...
    def __or__(self, other): ...
    def __div__(self, other): ...
    def __truediv__(self, other): ...
    def __radd__(self, other): ...
    def __rsub__(self, other): ...
    def __rmul__(self, other): ...
    def __rdiv__(self, other): ...
    def __rtruediv__(self, other): ...
    def __rfloordiv__(self, other): ...
    def __rmod__(self, other): ...
    def __rdivmod__(self, other): ...
    def __rpow__(self, other): ...
    def __rlshift__(self, other): ...
    def __rrshift__(self, other): ...
    def __rand__(self, other): ...
    def __ror__(self, other): ...
    def __neg__(self): ...
    def __pos__(self): ...
    def __abs__(self): ...
    def __invert__(self): ...
    def __complex__(self) -> complex: ...
    def __int__(self) -> int: ...
    def __float__(self) -> float: ...
    def __oct__(self): ...
    def __hex__(self): ...
    def __index__(self) -> int: ...
    def __le__(self, other): ...
    def __ge__(self, other): ...
    def __gt__(self, other): ...
    def __lt__(self, other): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def __hash__(self): ...
    def __bool__(self) -> bool: ...
    def __call__(self, *args, **kwargs): ...

class RelationshipDir(DAObject):
    def involves(self, target) -> bool: ...

class RelationshipPeer(DAObject):
    def involves(self, target) -> bool: ...

class RelationshipTree(DAObject):
    def init(self, *pargs, **kwargs) -> None: ...
    def new(self, *pargs, **kwargs): ...
    def _func_list(self, *pargs, **kwargs): ...
    def _and(self, *pargs, **kwargs): ...
    def _or(self, *pargs, **kwargs): ...
    def query_peer(self, *pargs, **kwargs): ...
    def query_dir(self, *pargs, **kwargs): ...
    def add_relationship_dir(self, parent: Incomplete | None = ..., child: Incomplete | None = ..., relationship_type: Incomplete | None = ...): ...
    def delete_dir(self, *pargs) -> None: ...
    def add_relationship_peer(self, *pargs, **kwargs): ...
    def delete_peer(self, *pargs) -> None: ...

class DAList(DAObject):
    elements: list
    auto_gather: bool
    ask_number: bool
    minimum_number: int | None
    there_are_any: bool
    gathered: bool
    revisit: bool
    object_type: Incomplete
    object_type_parameters: dict
    complete_attribute: Incomplete
    ask_object_type: bool
    def init(self, *pargs, **kwargs) -> None: ...
    def initializeObject(self, *pargs, **kwargs): ...
    def set_object_type(self, object_type) -> None: ...
    doing_gathered_and_complete: bool
    def gathered_and_complete(self): ...
    def item_name(self, item) -> str: ...
    def delitem(self, *pargs) -> None: ...
    def copy(self) -> list: ...
    def filter(self, *pargs, **kwargs) -> Self: ...
    def _trigger_gather(self) -> None: ...
    def reset_gathered(self, recursive: bool = ..., only_if_empty: bool = ..., mark_incomplete: bool = ...) -> None: ...
    def has_been_gathered(self) -> bool: ...
    def pop(self, *pargs): ...
    def item(self, index): ...
    def __add__(self, other): ...
    def __radd__(self, other): ...
    def index(self, *pargs, **kwargs): ...
    def clear(self) -> None: ...
    def fix_instance_name(self, old_instance_name, new_instance_name) -> None: ...
    def _set_instance_name_recursively(self, thename, matching: Incomplete | None = ...) -> None: ...
    def _mark_as_gathered_recursively(self) -> None: ...
    def _reset_gathered_recursively(self) -> None: ...
    def _reset_instance_names(self) -> None: ...
    def sort(self, *pargs, **kwargs): ...
    def reverse(self, *pargs, **kwargs): ...
    def sort_elements(self, *pargs, **kwargs): ...
    def appendObject(self, *pargs, **kwargs): ...
    def append(self, *pargs, **kwargs) -> None: ...
    def remove(self, *pargs) -> None: ...
    def _remove_items_by_number(self, *pargs) -> None: ...
    def insert(self, *pargs) -> None: ...
    def count(self, item) -> int: ...
    def extend(self, the_list) -> None: ...
    def first(self): ...
    def last(self): ...
    def does_verb(self, the_verb, **kwargs) -> str: ...
    def did_verb(self, the_verb, **kwargs) -> str: ...
    def as_singular_noun(self) -> str: ...
    def possessive(self, target, **kwargs): ...
    def quantity_noun(self, *pargs, **kwargs): ...
    def as_noun(self, *pargs, **kwargs) -> str: ...
    def number(self) -> int: ...
    def gathering_started(self) -> bool: ...
    def number_gathered(self, if_started: bool = ...) -> int: ...
    def current_index(self) -> int: ...
    def number_as_word(self, language: Incomplete | None = ..., capitalize: bool = ...): ...
    def complete_elements(self, complete_attribute: Incomplete | None = ...): ...
    def _complete_attributes(self, complete_attribute: Incomplete | None = ...) -> list: ...
    def _validate(self, item_object_type, complete_attribute) -> None: ...
    _appending_allowed: bool
    def _allow_appending(self) -> None: ...
    def _disallow_appending(self) -> None: ...
    _necessary_length: Incomplete
    def gather(self, number: Incomplete | None = ..., item_object_type: Incomplete | None = ..., minimum: Incomplete | None = ..., complete_attribute: Incomplete | None = ...): ...
    def comma_and_list(self, **kwargs) -> str: ...
    def __contains__(self, item) -> bool: ...
    def __iter__(self) -> Iterator: ...
    def _target_or_actual(self) -> int: ...
    def __len__(self) -> int: ...
    def __delitem__(self, index) -> None: ...
    def __reversed__(self): ...
    def _fill_up_to(self, index) -> None: ...
    def __setitem__(self, index, the_value): ...
    def __getitem__(self, index): ...
    def __str__(self) -> str: ...
    def __repr__(self): ...
    def union(self, other_set) -> "DASet": ...
    def intersection(self, other_set) -> "DASet": ...
    def difference(self, other_set) -> "DASet": ...
    def isdisjoint(self, other_set) -> bool: ...
    def issubset(self, other_set) -> bool: ...
    def issuperset(self, other_set) -> bool: ...
    def pronoun_possessive(self, target, **kwargs) -> str: ...
    def pronoun(self, **kwargs) -> str: ...
    def pronoun_objective(self, **kwargs) -> str: ...
    def pronoun_subjective(self, **kwargs) -> str: ...
    def _reorder(self, *pargs) -> None: ...
    def item_actions(self, *pargs, **kwargs) -> str: ...
    def add_action(self, label: str | None = ..., message: str | None = ..., url_only: bool = ..., icon: str = ..., color: str | None = ..., size: str = ..., block: Incomplete | None = ..., classname: Incomplete | None = ...) -> str: ...
    def hook_on_gather(self, *pargs, **kwargs) -> None: ...
    def hook_after_gather(self, *pargs, **kwargs) -> None: ...
    def hook_on_item_complete(self, item, *pargs, **kwargs) -> None: ...
    def hook_on_remove(self, item, *pargs, **kwargs) -> None: ...
    def __eq__(self, other) -> bool: ...
    def __hash__(self) -> int: ...

class DADict(DAObject):
    elements: dict
    auto_gather: bool
    ask_number: bool
    minimum_number: Incomplete
    gathered: bool
    revisit: bool
    object_type: Incomplete
    object_type_parameters: Incomplete
    complete_attribute: Incomplete
    ask_object_type: bool
    def init(self, *pargs, **kwargs) -> None: ...
    def set_object_type(self, object_type) -> None: ...
    def _trigger_gather(self) -> None: ...
    def fix_instance_name(self, old_instance_name, new_instance_name) -> None: ...
    def _set_instance_name_recursively(self, thename, matching: Incomplete | None = ...) -> None: ...
    def _mark_as_gathered_recursively(self) -> None: ...
    def _reset_gathered_recursively(self) -> None: ...
    def item_name(self, item): ...
    def delitem(self, *pargs) -> None: ...
    def invalidate_item(self, *pargs) -> None: ...
    def getitem_fresh(self, item): ...
    def all_false(self, *pargs, **kwargs) -> bool: ...
    def any_true(self, *pargs, **kwargs) -> bool: ...
    def any_false(self, *pargs, **kwargs) -> bool: ...
    def all_true(self, *pargs, **kwargs) -> bool: ...
    def true_values(self, insertion_order: bool = ...) -> DAList: ...
    def false_values(self, insertion_order: bool = ...) -> DAList: ...
    def _sorted_items(self): ...
    def _sorted_elements_items(self): ...
    def _sorted_iteritems(self): ...
    def _sorted_elements_iteritems(self): ...
    there_are_any: bool
    def initializeObject(self, *pargs, **kwargs): ...
    def new(self, *pargs, **kwargs) -> None: ...
    def reset_gathered(self, recursive: bool = ..., only_if_empty: bool = ..., mark_incomplete: bool = ...) -> None: ...
    def slice(self, *pargs): ...
    def has_been_gathered(self) -> bool: ...
    def does_verb(self, the_verb, **kwargs): ...
    def did_verb(self, the_verb, **kwargs): ...
    def as_singular_noun(self): ...
    def quantity_noun(self, *pargs, **kwargs): ...
    def as_noun(self, *pargs, **kwargs): ...
    def possessive(self, target, **kwargs): ...
    def number(self) -> int: ...
    def gathering_started(self) -> bool: ...
    def number_gathered(self, if_started: bool = ...) -> int: ...
    def number_as_word(self, language: Incomplete | None = ...): ...
    def complete_elements(self, complete_attribute: Incomplete | None = ...): ...
    def _sorted_keys(self): ...
    def _sorted_elements_keys(self): ...
    def _complete_attributes(self, complete_attribute: Incomplete | None = ...): ...
    def _validate(self, item_object_type, complete_attribute, keys: Incomplete | None = ...) -> None: ...
    doing_gathered_and_complete: bool
    def gathered_and_complete(self): ...
    def gather(self, item_object_type: Incomplete | None = ..., number: Incomplete | None = ..., minimum: Incomplete | None = ..., complete_attribute: Incomplete | None = ..., keys: Incomplete | None = ...): ...
    def _sorted_elements_values(self): ...
    def _sorted_values(self): ...
    def _new_item_init_callback(self) -> None: ...
    def comma_and_list(self, **kwargs): ...
    def __getitem__(self, index): ...
    def __setitem__(self, key, the_value) -> None: ...
    def __contains__(self, item) -> bool: ...
    def keys(self): ...
    def values(self): ...
    def update(self, *pargs, **kwargs) -> None: ...
    def pop(self, *pargs): ...
    def popitem(self): ...
    def setdefault(self, *pargs): ...
    def get(self, *pargs): ...
    def clear(self) -> None: ...
    def copy(self): ...
    def has_key(self, key) -> bool: ...
    def item(self, key): ...
    def items(self): ...
    def iteritems(self): ...
    def iterkeys(self): ...
    def itervalues(self): ...
    def __iter__(self): ...
    def _target_or_actual(self) -> int: ...
    def __len__(self) -> int: ...
    def __reversed__(self): ...
    def __delitem__(self, key): ...
    def __missing__(self, key): ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def union(self, other_set): ...
    def intersection(self, other_set): ...
    def difference(self, other_set): ...
    def isdisjoint(self, other_set): ...
    def issubset(self, other_set): ...
    def issuperset(self, other_set): ...
    def pronoun_possessive(self, target, **kwargs): ...
    def pronoun(self, **kwargs): ...
    def pronoun_objective(self, **kwargs): ...
    def pronoun_subjective(self, **kwargs): ...
    def item_actions(self, *pargs, **kwargs): ...
    def add_action(self, label: Incomplete | None = ..., message: Incomplete | None = ..., url_only: bool = ..., icon: str = ..., color: Incomplete | None = ..., size: str = ..., block: Incomplete | None = ..., classname: Incomplete | None = ...): ...
    def _new_elements(self) -> dict: ...
    def hook_on_gather(self, *pargs, **kwargs) -> None: ...
    def hook_after_gather(self, *pargs, **kwargs) -> None: ...
    def hook_on_item_complete(self, item, *pargs, **kwargs) -> None: ...
    def hook_on_remove(self, item, *pargs, **kwargs) -> None: ...
    def __eq__(self, other) -> bool: ...
    def __hash__(self) -> int: ...

class DAOrderedDict(DADict):
    def _new_elements(self) -> OrderedDict: ...
    def _sorted_items(self): ...
    def _sorted_elements_items(self): ...
    def _sorted_iteritems(self): ...
    def _sorted_elements_iteritems(self): ...
    def _sorted_keys(self): ...
    def _sorted_elements_keys(self): ...
    def _sorted_values(self): ...
    def _sorted_elements_values(self): ...

class DASet(DAObject):
    elements: Incomplete
    auto_gather: bool
    ask_number: bool
    minimum_number: Incomplete
    gathered: bool
    revisit: bool
    def init(self, *pargs, **kwargs) -> None: ...
    doing_gathered_and_complete: bool
    def gathered_and_complete(self): ...
    def complete_elements(self, complete_attribute: Incomplete | None = ...): ...
    def filter(self, *pargs, **kwargs): ...
    def _trigger_gather(self) -> None: ...
    def reset_gathered(self, recursive: bool = ..., only_if_empty: bool = ..., mark_incomplete: bool = ...) -> None: ...
    def has_been_gathered(self): ...
    def _reset_gathered_recursively(self) -> None: ...
    def copy(self): ...
    def clear(self) -> None: ...
    there_are_any: bool
    def remove(self, elem) -> None: ...
    def discard(self, elem) -> None: ...
    def pop(self): ...
    def add(self, *pargs) -> None: ...
    def does_verb(self, the_verb, **kwargs): ...
    def did_verb(self, the_verb, **kwargs): ...
    def as_singular_noun(self): ...
    def quantity_noun(self, *pargs, **kwargs): ...
    def as_noun(self, *pargs, **kwargs): ...
    def number(self) -> int: ...
    def gathering_started(self): ...
    def number_gathered(self, if_started: bool = ...): ...
    def number_as_word(self, language: Incomplete | None = ...): ...
    def gather(self, number: Incomplete | None = ..., minimum: Incomplete | None = ...): ...
    def comma_and_list(self, **kwargs): ...
    def __contains__(self, item) -> bool: ...
    def __iter__(self): ...
    def _target_or_actual(self) -> int: ...
    def __len__(self) -> int: ...
    def __reversed__(self): ...
    def __and__(self, operand): ...
    def __or__(self, operand): ...
    def __iand__(self, operand): ...
    def __ior__(self, operand): ...
    def __isub__(self, operand): ...
    def __ixor__(self, operand): ...
    def __rand__(self, operand): ...
    def __ror__(self, operand): ...
    def __hash__(self) -> int: ...
    def __add__(self, other): ...
    def __sub__(self, other): ...
    def __str__(self) -> str: ...
    def __repr__(self): ...
    def union(self, other_set) -> "DASet": ...
    def intersection(self, other_set) -> "DASet": ...
    def difference(self, other_set) -> "DASet": ...
    def isdisjoint(self, other_set) -> bool: ...
    def issubset(self, other_set) -> bool: ...
    def issuperset(self, other_set) -> bool: ...
    def pronoun_possessive(self, target, **kwargs) -> str: ...
    def pronoun(self, **kwargs) -> str: ...
    def pronoun_objective(self, **kwargs) -> str: ...
    def pronoun_subjective(self, **kwargs) -> str: ...
    def hook_on_gather(self, *pargs, **kwargs) -> None: ...
    def hook_after_gather(self, *pargs, **kwargs) -> None: ...
    def hook_on_item_complete(self, item, *pargs, **kwargs) -> None: ...
    def hook_on_remove(self, item, *pargs, **kwargs) -> None: ...
    def __eq__(self, other) -> bool: ...

class DAFile(DAObject):
    filename: Incomplete
    has_specific_filename: bool
    mimetype: Incomplete
    extension: Incomplete
    content: Incomplete
    markdown: Incomplete
    alt_text: Incomplete
    number: Incomplete
    ok: bool
    initialized: bool
    def init(self, *pargs, **kwargs) -> None: ...
    def convert_to(self, output_extension, output_to: Incomplete | None = ...) -> None: ...
    def fix_up(self) -> None: ...
    def set_alt_text(self, alt_text) -> None: ...
    def get_alt_text(self): ...
    def set_mimetype(self, mimetype) -> None: ...
    def __str__(self): ...
    def initialize(self, **kwargs) -> None: ...
    file_info: Incomplete
    persistent: Incomplete
    private: Incomplete
    def retrieve(self) -> None: ...
    def size_in_bytes(self) -> int: ...
    def slurp(self, auto_decode: bool = ...) -> str: ...
    def readlines(self): ...
    def write(self, content, binary: bool = ...) -> None: ...
    def copy_into(self, other_file) -> None: ...
    def extract_pages(self, first: Incomplete | None = ..., last: Incomplete | None = ..., output_to: Incomplete | None = ...): ...
    def bates_number(self, *pargs, **kwargs) -> None: ...
    def make_ocr_pdf(self, *pargs, **kwargs) -> None: ...
    def make_ocr_pdf_in_background(self, *pargs, **kwargs): ...
    def _is_pdf(self) -> bool: ...
    def get_docx_variables(self) -> list: ...
    def get_pdf_fields(self) -> list: ...
    def from_url(self, url) -> None: ...
    def uses_acroform(self) -> bool: ...
    def is_encrypted(self) -> bool: ...
    def _make_pdf_thumbnail(self, page, both_formats: bool = ...) -> None: ...
    def pngs_ready(self) -> bool: ...
    def _delete_pngs(self) -> None: ...
    def _make_pngs_for_pdf(self) -> None: ...
    def num_pages(self) -> int: ...
    def _pdf_page_path(self, page): ...
    def _path_ready(self, the_path): ...
    def page_path(self, page, prefix, wait: bool = ...): ...
    def cloud_path(self, filename: Incomplete | None = ...): ...
    def path(self): ...
    def commit(self) -> None: ...
    def show(self, width: Incomplete | None = ..., wait: bool = ..., alt_text: Incomplete | None = ...) -> str: ...
    def _pdf_pages(self, width): ...
    def url_for(self, **kwargs): ...
    def set_attributes(self, **kwargs): ...
    def user_access(self, *pargs, **kwargs): ...
    def privilege_access(self, *pargs, **kwargs): ...

class DAFileCollection(DAObject):
    info: Incomplete
    def init(self, *pargs, **kwargs) -> None: ...
    def _extension_list(self) -> list[str]: ...
    def fix_up(self) -> None: ...
    def set_alt_text(self, alt_text) -> None: ...
    def get_alt_text(self): ...
    def uses_acroform(self) -> bool: ...
    def is_encrypted(self) -> bool: ...
    def num_pages(self) -> int: ...
    def _first_file(self): ...
    def path(self): ...
    def get_docx_variables(self) -> list | None: ...
    def get_pdf_fields(self) -> list | None: ...
    def url_for(self, **kwargs): ...
    def set_attributes(self, **kwargs) -> None: ...
    def user_access(self, *pargs, **kwargs) -> None: ...
    def privilege_access(self, *pargs, **kwargs) -> None: ...
    def show(self, **kwargs) -> str: ...
    def extract_pages(self, first: Incomplete | None = ..., last: Incomplete | None = ...): ...
    def bates_number(self, **kwargs) -> None: ...
    def make_ocr_pdf(self, **kwargs) -> None: ...
    def make_ocr_pdf_in_background(self, **kwargs): ...
    def __str__(self) -> str: ...

class DAFileList(DAList):
    def __str__(self) -> str: ...
    def fix_up(self) -> None: ...
    def set_alt_text(self, alt_text) -> None: ...
    def get_alt_text(self): ...
    def num_pages(self) -> int: ...
    def uses_acroform(self) -> bool | None: ...
    def is_encrypted(self) -> bool | None: ...
    def convert_to(self, output_extension, output_to: Incomplete | None = ...) -> None: ...
    def size_in_bytes(self) -> int | None: ...
    def slurp(self, auto_decode: bool = ...) -> str | None: ...
    def show(self, width: Incomplete | None = ..., alt_text: Incomplete | None = ...) -> str: ...
    def path(self) -> str | None: ...
    def get_docx_variables(self) -> list | None: ...
    def get_pdf_fields(self) -> list | None: ...
    def url_for(self, **kwargs): ...
    def set_attributes(self, **kwargs) -> None: ...
    def user_access(self, *pargs, **kwargs) -> None: ...
    def privilege_access(self, *pargs, **kwargs) -> None: ...
    def extract_pages(self, first: Incomplete | None = ..., last: Incomplete | None = ...): ...
    elements: Incomplete
    def bates_number(self, **kwargs) -> None: ...
    def make_ocr_pdf(self, **kwargs) -> None: ...
    def make_ocr_pdf_in_background(self, **kwargs): ...

class DAStaticFile(DAObject):
    package: Incomplete
    def init(self, *pargs, **kwargs) -> None: ...
    def _populate(self) -> None: ...
    def get_alt_text(self) -> str | None: ...
    alt_text: Incomplete
    def set_alt_text(self, alt_text) -> None: ...
    def _get_unqualified_reference(self) -> str: ...
    def show(self, width: Incomplete | None = ..., alt_text: Incomplete | None = ...) -> str: ...
    def _pdf_pages(self, width): ...
    def uses_acroform(self) -> bool: ...
    def is_encrypted(self) -> bool: ...
    def size_in_bytes(self) -> int: ...
    def slurp(self, auto_decode: bool = ...) -> str: ...
    def path(self) -> Any | None: ...
    def get_docx_variables(self) -> list: ...
    def get_pdf_fields(self) -> list: ...
    def url_for(self, **kwargs): ...
    def _is_pdf(self) -> bool: ...
    def __str__(self) -> str: ...

class DAEmailRecipientList(DAList):
    object_type: Incomplete
    def init(self, *pargs, **kwargs) -> None: ...

class DAEmailRecipient(DAObject):
    address: Incomplete
    name: Incomplete
    def init(self, *pargs, **kwargs) -> None: ...
    def email_address(self, include_name: bool | None = ...) -> str: ...
    def exists(self) -> bool: ...
    def __str__(self) -> str: ...

class DAEmail(DAObject):
    def __str__(self) -> str: ...

class DATemplate(DAObject):
    content: Incomplete
    subject: Incomplete
    decorations: Incomplete
    def init(self, *pargs, **kwargs) -> None: ...
    def show(self, **kwargs) -> str: ...
    def show_as_markdown(self, **kwargs) -> str: ...
    def __str__(self) -> str: ...

class DALazyTemplate(DAObject):
    def __getstate__(self) -> dict: ...
    def subject_as_html(self, **kwargs): ...
    def content_as_html(self, **kwargs): ...
    @property
    def subject(self, **kwargs): ...
    @property
    def content(self, **kwargs): ...
    @property
    def decorations(self) -> list: ...
    def show(self, **kwargs): ...
    def show_as_markdown(self, **kwargs): ...
    def __str__(self) -> str: ...

class DALazyTableTemplate(DALazyTemplate):
    def show(self, **kwargs): ...
    @property
    def content(self, **kwargs): ...
    def export(self, filename: Incomplete | None = ..., file_format: Incomplete | None = ..., title: Incomplete | None = ..., freeze_panes: bool = ..., output_to: Incomplete | None = ...): ...
    def as_df(self): ...
    def export_safe_eval(self, x, user_dict_copy): ...
    def header_and_contents(self): ...

def selections(*pargs, **kwargs): ...
def objects_from_file(file_ref, recursive: bool = ..., gathered: bool = ..., name: Incomplete | None = ..., use_objects: bool = ..., package: Incomplete | None = ...): ...

class DALink(DAObject):
    def __str__(self) -> str: ...
    def show(self) -> str: ...

class DAContext(DADict):
    pargs: Incomplete
    kwargs: Incomplete
    def init(self, *pargs, **kwargs) -> None: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __hash__(self) -> int: ...

class DASessionLocal(DAObject):
    def __init__(self, *pargs, **kwargs) -> None: ...

class DADeviceLocal(DAObject):
    def __init__(self, *pargs, **kwargs) -> None: ...

class DAUserLocal(DAObject):
    def __init__(self, *pargs, **kwargs) -> None: ...

class DAGlobal(DAObject):
    @classmethod
    def keys(cls, base): ...
    @classmethod
    def defined(cls, base, key): ...
    base: str
    key: Incomplete
    def init(self, *pargs, **kwargs) -> None: ...
    def __getstate__(self): ...
    __dict__: Incomplete
    def __setstate__(self, pickle_dict) -> None: ...
    def delete(self) -> None: ...

class DAStore(DAObject):
    def is_encrypted(self): ...
    def _get_base_key(self): ...
    def defined(self, key): ...
    def get(self, key): ...
    def set(self, key, the_value) -> None: ...
    def delete(self, key) -> None: ...
    def keys(self): ...

class DAWeb(DAObject):
    def _get_base_url(self): ...
    def _get_on_failure(self, on_failure): ...
    def _get_success_code(self, success_code): ...
    def _get_on_success(self, on_success): ...
    def _get_task(self, task): ...
    def _get_task_persistent(self, task_persistent): ...
    def _get_auth(self, auth): ...
    def _get_headers(self, new_headers): ...
    def _get_cookies(self, new_cookies): ...
    def _get_json_body(self, json_body): ...
    cookies: Incomplete
    def _call(self, url, method: Incomplete | None = ..., data: Incomplete | None = ..., params: Incomplete | None = ..., headers: Incomplete | None = ..., json_body: Incomplete | None = ..., on_failure: Incomplete | None = ..., on_success: Incomplete | None = ..., auth: Incomplete | None = ..., task: Incomplete | None = ..., task_persistent: Incomplete | None = ..., files: Incomplete | None = ..., cookies: Incomplete | None = ..., success_code: Incomplete | None = ...): ...
    def get(self, url, data: Incomplete | None = ..., params: Incomplete | None = ..., headers: Incomplete | None = ..., json_body: Incomplete | None = ..., on_failure: Incomplete | None = ..., on_success: Incomplete | None = ..., auth: Incomplete | None = ..., cookies: Incomplete | None = ..., task: Incomplete | None = ..., task_persistent: Incomplete | None = ...): ...
    def post(self, url, data: Incomplete | None = ..., params: Incomplete | None = ..., headers: Incomplete | None = ..., json_body: Incomplete | None = ..., on_failure: Incomplete | None = ..., on_success: Incomplete | None = ..., auth: Incomplete | None = ..., cookies: Incomplete | None = ..., task: Incomplete | None = ..., task_persistent: Incomplete | None = ..., files: Incomplete | None = ...): ...
    def put(self, url, data: Incomplete | None = ..., params: Incomplete | None = ..., headers: Incomplete | None = ..., json_body: Incomplete | None = ..., on_failure: Incomplete | None = ..., on_success: Incomplete | None = ..., auth: Incomplete | None = ..., cookies: Incomplete | None = ..., task: Incomplete | None = ..., task_persistent: Incomplete | None = ..., files: Incomplete | None = ...): ...
    def patch(self, url, data: Incomplete | None = ..., params: Incomplete | None = ..., headers: Incomplete | None = ..., json_body: Incomplete | None = ..., on_failure: Incomplete | None = ..., on_success: Incomplete | None = ..., auth: Incomplete | None = ..., cookies: Incomplete | None = ..., task: Incomplete | None = ..., task_persistent: Incomplete | None = ..., files: Incomplete | None = ...): ...
    def delete(self, url, data: Incomplete | None = ..., params: Incomplete | None = ..., headers: Incomplete | None = ..., json_body: Incomplete | None = ..., on_failure: Incomplete | None = ..., on_success: Incomplete | None = ..., auth: Incomplete | None = ..., cookies: Incomplete | None = ..., task: Incomplete | None = ..., task_persistent: Incomplete | None = ...): ...
    def options(self, url, data: Incomplete | None = ..., params: Incomplete | None = ..., headers: Incomplete | None = ..., json_body: Incomplete | None = ..., on_failure: Incomplete | None = ..., on_success: Incomplete | None = ..., auth: Incomplete | None = ..., cookies: Incomplete | None = ..., task: Incomplete | None = ..., task_persistent: Incomplete | None = ...): ...
    def head(self, url, data: Incomplete | None = ..., params: Incomplete | None = ..., headers: Incomplete | None = ..., json_body: Incomplete | None = ..., on_failure: Incomplete | None = ..., on_success: Incomplete | None = ..., auth: Incomplete | None = ..., cookies: Incomplete | None = ..., task: Incomplete | None = ..., task_persistent: Incomplete | None = ...): ...

class DARedis(DAObject):
    def key(self, keyname) -> str: ...
    def get_data(self, key) -> Optional[Any]: ...
    def set_data(self, key, data, expire: Incomplete | None = ...) -> None: ...
    def __getattr__(self, funcname): ...

class DACloudStorage(DAObject):
    custom: bool
    provider: Incomplete
    config: Incomplete
    def init(self, *pargs, **kwargs) -> None: ...
    @property
    def conn(self): ...
    @property
    def client(self): ...
    @property
    def bucket(self): ...
    @property
    def bucket_name(self): ...
    @property
    def container_name(self): ...

class DAGoogleAPI(DAObject):
    def api_credentials(self, scope): ...
    def http(self, scope): ...
    def drive_service(self): ...
    def sheets_service(self): ...
    def cloud_credentials(self, scope): ...
    def project_id(self): ...
    def google_cloud_storage_client(self): ...
    def google_cloud_vision_client(self): ...

def run_python_module(module, arguments: Incomplete | None = ...): ...
def today(timezone: Incomplete | None = ..., format: Incomplete | None = ...): ...
def month_of(the_date, as_word: bool = ..., language: Incomplete | None = ...) -> int | str: ...
def day_of(the_date, language: Incomplete | None = ...) -> int | str: ...
def dow_of(the_date, as_word: bool = ..., language: Incomplete | None = ...) -> int | str: ...
def year_of(the_date, language: Incomplete | None = ...) -> int | str: ...
def format_date(the_date, format: Incomplete | None = ..., language: Incomplete | None = ...): ...
def format_datetime(the_date, format: Incomplete | None = ..., language: Incomplete | None = ...): ...
def format_time(the_time, format: Incomplete | None = ..., language: Incomplete | None = ...): ...

class DateTimeDelta:
    def __str__(self): ...
    def describe(self, **kwargs): ...

class DADateTime(datetime.datetime):
    def format(self, format: Incomplete | None = ..., language: Incomplete | None = ...): ...
    def format_date(self, format: Incomplete | None = ..., language: Incomplete | None = ...): ...
    def format_datetime(self, format: Incomplete | None = ..., language: Incomplete | None = ...): ...
    def format_time(self, format: Incomplete | None = ..., language: Incomplete | None = ...): ...
    def replace_time(self, the_time): ...
    @property
    def nanosecond(self) -> int: ...
    @property
    def dow(self): ...
    @property
    def week(self): ...
    def plus(self, **kwargs): ...
    def minus(self, **kwargs): ...
    def __str__(self): ...
    def __add__(self, other): ...
    def __radd__(self, other): ...
    def __sub__(self, other): ...
    def __rsub__(self, other): ...

def current_datetime(timezone: Incomplete | None = ...) -> DADateTime: ...
def as_datetime(the_date, timezone: Incomplete | None = ...) -> DADateTime: ...
def date_interval(**kwargs): ...
def date_difference(starting: Incomplete | None = ..., ending: Incomplete | None = ..., timezone: Incomplete | None = ...): ...
def timezone_list() -> list: ...
def returning_user(minutes: Incomplete | None = ..., hours: Incomplete | None = ..., days: Incomplete | None = ...) -> bool: ...
def last_access_delta(*pargs, **kwargs): ...
def last_access_days(*pargs, **kwargs) -> float: ...
def last_access_hours(*pargs, **kwargs) -> float: ...
def last_access_minutes(*pargs, **kwargs) -> float: ...
def last_access_time(include_privileges: Incomplete | None = ..., exclude_privileges: Incomplete | None = ..., include_cron: bool = ..., timezone: Incomplete | None = ...): ...
def start_time(timezone: Incomplete | None = ...): ...

class LatitudeLongitude(DAObject):
    gathered: bool
    known: bool
    def init(self, *pargs, **kwargs) -> None: ...
    def status(self): ...
    latitude: Incomplete
    longitude: Incomplete
    error: Incomplete
    description: Incomplete
    def _set_to_current(self) -> None: ...
    def __str__(self): ...

class RoleChangeTracker(DAObject):
    last_role: Incomplete
    def init(self, *pargs, **kwargs) -> None: ...
    def _update(self, target_role) -> None: ...
    def send_email(self, roles_needed, **kwargs): ...

class Name(DAObject):
    def full(self, **kwargs) -> str: ...
    def familiar(self) -> str: ...
    def firstlast(self) -> str: ...
    def lastfirst(self) -> str: ...
    def middle_initial(self, with_period: bool = ...) -> str: ...
    def defined(self) -> bool: ...
    def __str__(self) -> str: ...

class IndividualName(Name):
    uses_parts: bool
    def init(self, *pargs, **kwargs) -> None: ...
    def defined(self) -> bool: ...
    def familiar(self) -> str: ...
    def full(self, middle: str = ..., use_suffix: bool = ..., **kwargs) -> str: ...
    def firstlast(self) -> str: ...
    def lastfirst(self) -> str: ...
    def middle_initial(self, with_period: bool = ...) -> str: ...

class Address(DAObject):
    LatitudeLongitudeClass: Incomplete
    _geocoded: bool
    geolocated: bool
    city_only: bool
    def init(self, *pargs, **kwargs) -> None: ...
    def __str__(self) -> str: ...
    def on_one_line(self, include_unit: bool = ..., omit_default_country: bool = ..., language: str | None = ..., show_country: bool | None = ...) -> str: ...
    def _map_info(self) -> list[dict[str, Any]] | None: ...
    def was_geocoded(self) -> bool: ...
    def was_geocoded_successfully(self) -> bool: ...
    def get_geocode_response(self): ...
    def geolocate(self, address: Incomplete | None = ..., reset: bool = ...): ...
    _geocode_success: bool
    geolocate_success: bool
    _geocode_response: Incomplete
    geolocate_response: Incomplete
    def geocode(self, address: Incomplete | None = ..., reset: bool = ...) -> bool: ...
    norm: Incomplete
    norm_long: Incomplete
    def normalize(self, long_format: bool = ...) -> bool: ...
    def reset_geolocation(self) -> None: ...
    def reset_geocoding(self) -> None: ...
    def block(self, language: Incomplete | None = ..., international: bool = ..., show_country: Incomplete | None = ...): ...
    def _get_country(self): ...
    def formatted_unit(self, language: Incomplete | None = ..., require: bool = ...): ...
    def line_one(self, language: Incomplete | None = ...) -> bool: ...
    def line_two(self, language: Incomplete | None = ...) -> bool: ...

def iso_country(country, part: str = ...): ...

class City(Address):
    city_only: bool
    def init(self, *pargs, **kwargs) -> None: ...

class Thing(DAObject):
    NameClass: Incomplete
    def init(self, *pargs, **kwargs) -> None: ...
    def __setattr__(self, attrname, the_value) -> None: ...
    def __str__(self) -> str: ...

class Event(DAObject):
    CityClass: Incomplete
    LatitudeLongitudeClass: Incomplete
    def init(self, *pargs, **kwargs) -> None: ...
    def __str__(self): ...

class Person(DAObject):
    NameClass: Type[Name] = Name
    AddressClass: Type[Address] = Address
    LatitudeLongitudeClass: Incomplete
    def init(self, *pargs, **kwargs) -> None: ...
    location: Incomplete
    def _map_info(self): ...
    def identified(self) -> bool: ...
    def __setattr__(self, attrname, the_value) -> None: ...
    def __str__(self) -> str: ...
    def pronoun_objective(self, **kwargs) -> str: ...
    def possessive(self, target, **kwargs) -> str: ...
    def object_possessive(self, target, **kwargs) -> str: ...
    def is_are_you(self, **kwargs) -> str: ...
    def is_user(self) -> bool: ...
    def address_block(self, language: Incomplete | None = ..., international: bool = ..., show_country: bool = ...) -> str: ...
    def sms_number(self, country: Incomplete | None = ...): ...
    def facsimile_number(self, country: Incomplete | None = ...): ...
    def email_address(self, include_name: Incomplete | None = ...) -> str: ...
    def do_question(self, the_verb, **kwargs) -> str: ...
    def did_question(self, the_verb, **kwargs) -> str: ...
    def were_question(self, the_target, **kwargs) -> str: ...
    def have_question(self, the_target, **kwargs) -> str: ...
    def does_verb(self, the_verb, **kwargs) -> str: ...
    def did_verb(self, the_verb, **kwargs) -> str: ...
    def subject(self, **kwargs) -> str: ...

class Individual(Person):
    NameClass: Type[Name]
    def init(self, *pargs, **kwargs) -> None: ...
    def familiar(self) -> str: ...
    def gather_family(self, tree, up: int = ..., down: int = ...) -> None: ...
    def identified(self) -> bool: ...
    def age_in_years(self, decimals: bool = ..., as_of: Incomplete | None = ...) -> int | float: ...
    def first_name_hint(self) -> str: ...
    def last_name_hint(self) -> str: ...
    def salutation(self, **kwargs) -> str: ...
    def pronoun_possessive(self, target, **kwargs) -> str: ...
    def pronoun(self, **kwargs) -> str: ...
    def pronoun_objective(self, **kwargs) -> str: ...
    def pronoun_subjective(self, **kwargs) -> str: ...
    def yourself_or_name(self, **kwargs) -> str: ...
    def __setattr__(self, attrname, the_value) -> None: ...
    def __str__(self) -> str: ...

class ChildList(DAList):
    ChildClass: Incomplete
    object_type: Incomplete
    def init(self, *pargs, **kwargs) -> None: ...

class Value(DAObject):
    def amount(self) -> int | Decimal: ...
    def __str__(self) -> str: ...
    def __float__(self) -> float: ...
    def __int__(self) -> int: ...
    def __le__(self, other) -> bool: ...
    def __ge__(self, other) -> bool: ...
    def __gt__(self, other) -> bool: ...
    def __lt__(self, other) -> bool: ...
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def __hash__(self) -> int: ...

class PeriodicValue(Value):
    def amount(self, period_to_use: int = ...) -> int | Decimal: ...

class FinancialList(DADict):
    ValueClass: Incomplete
    object_type: Incomplete
    def init(self, *pargs, **kwargs) -> None: ...
    def total(self) -> int | Decimal: ...
    def existing_items(self) -> list: ...
    def _new_item_init_callback(self): ...
    def __str__(self) -> str: ...

class PeriodicFinancialList(FinancialList):
    PeriodicValueClass: Incomplete
    object_type: Incomplete
    def init(self, *pargs, **kwargs) -> None: ...
    def total(self, period_to_use: int = ...) -> int | Decimal: ...
    def _new_item_init_callback(self): ...

class Income(PeriodicFinancialList): ...
class Asset(FinancialList): ...
class Expense(PeriodicFinancialList): ...

class OfficeList(DAList):
    AddressClass: Incomplete
    object_type: Incomplete
    def init(self, *pargs, **kwargs) -> None: ...

class Organization(Person):
    OfficeListClass: Incomplete
    def init(self, *pargs, **kwargs) -> None: ...
    def will_handle(self, problem: Incomplete | None = ..., county: Incomplete | None = ...) -> bool: ...
    def _map_info(self) -> list | None: ...

def get_sms_session(phone_number, config: str = ...): ...
def initiate_sms_session(phone_number, yaml_filename: Incomplete | None = ..., email: Incomplete | None = ..., new: bool = ..., send: bool = ..., config: str = ...) -> bool: ...
def terminate_sms_session(phone_number, config: str = ...): ...
def send_sms(to: Incomplete | None = ..., body: Incomplete | None = ..., template: Incomplete | None = ..., task: Incomplete | None = ..., task_persistent: bool = ..., attachments: Incomplete | None = ..., config: str = ..., dry_run: bool = ...) -> bool: ...

class FaxStatus:
    sid: Incomplete
    def __init__(self, sid) -> None: ...
    def status(self): ...
    def pages(self): ...
    def info(self): ...
    def received(self): ...

def send_fax(fax_number, file_object, config: str = ..., country: Incomplete | None = ...) -> FaxStatus: ...
def send_email(to: Incomplete | None = ..., sender: Incomplete | None = ..., reply_to: Incomplete | None = ..., cc: Incomplete | None = ..., bcc: Incomplete | None = ..., body: Incomplete | None = ..., html: Incomplete | None = ..., subject: str = ..., template: Incomplete | None = ..., task: Incomplete | None = ..., task_persistent: bool = ..., attachments: Incomplete | None = ..., mailgun_variables: Incomplete | None = ..., dry_run: bool = ..., config: Incomplete | None = ...) -> bool: ...
def map_of(*pargs, **kwargs): ...
def ocr_file_in_background(*pargs, **kwargs): ...
def ocr_file(image_file, language: Incomplete | None = ..., psm: int = ..., f: Incomplete | None = ..., l: Incomplete | None = ..., x: Incomplete | None = ..., y: Incomplete | None = ..., W: Incomplete | None = ..., H: Incomplete | None = ..., use_google: bool = ..., raw_result: bool = ...): ...
def read_qr(image_file, f: Incomplete | None = ..., l: Incomplete | None = ..., x: Incomplete | None = ..., y: Incomplete | None = ..., W: Incomplete | None = ..., H: Incomplete | None = ...): ...
def path_and_mimetype(file_ref): ...

class DummyObject:
    def __init__(self, *pargs, **kwargs) -> None: ...
SimpleTextMachineLearner = DummyObject
SVMMachineLearner = DummyObject
RandomForestMachineLearner = DummyObject
MachineLearningEntry = DummyObject

class DAModel(DAObject):
    store: Incomplete
    group_id: Incomplete
    key: Incomplete
    use_for_training: Incomplete
    learner: Incomplete
    text: Incomplete
    def init(self, *pargs, **kwargs) -> None: ...
    def __str__(self): ...
    entry_id: Incomplete
    predictions: Incomplete
    prediction: Incomplete
    probability: Incomplete
    def predict(self) -> None: ...

def docx_concatenate(*pargs, **kwargs): ...
def pdf_concatenate(*pargs, **kwargs): ...
def zip_file(*pargs, **kwargs): ...
def validation_error(the_message, field: Incomplete | None = ...) -> None: ...
def url_ask(data): ...
def action_button_html(url, icon: str | None = ..., color: str = ..., size: str = ..., block: bool = ..., label: str = ..., classname: Incomplete | None = ..., new_window: Incomplete | None = ..., id_tag: Incomplete | None = ...) -> str: ...
def overlay_pdf(main_pdf, logo_pdf, first_page: Incomplete | None = ..., last_page: Incomplete | None = ..., logo_page: Incomplete | None = ..., only: Incomplete | None = ..., multi: bool = ..., output_to: Incomplete | None = ..., filename: Incomplete | None = ...): ...
def explain(the_explanation, category: str = ...) -> None: ...
def clear_explanations(category: str = ...) -> None: ...
def logic_explanation(category: str = ...): ...
def set_status(**kwargs) -> None: ...
def get_status(setting) -> Optional[Any]: ...
def assemble_docx(input_file, fields: Incomplete | None = ..., output_path: Incomplete | None = ..., output_format: str = ..., return_content: bool = ..., pdf_options: Incomplete | None = ..., filename: Incomplete | None = ...): ...
def variables_snapshot_connection(): ...
def task_performed(task, persistent: bool = ...) -> bool: ...
def task_not_yet_performed(task, persistent: bool = ...) -> bool: ...
def mark_task_as_performed(task, persistent: bool = ...): ...
def times_task_performed(task, persistent: bool = ...): ...
def set_task_counter(task, times, persistent: bool = ...) -> None: ...
def stash_data(data, expire: Incomplete | None = ...): ...
def retrieve_stashed_data(stash_key, secret, delete: bool = ..., refresh: bool = ...): ...

class DABreadCrumbs(DAObject):
    def get_crumbs(self): ...
    def show(self): ...
    def container(self, items) -> str: ...
    def inner(self, label, active) -> str: ...

class DAOAuth(DAObject):
    url_args: Incomplete
    def init(self, *pargs, **kwargs) -> None: ...
    def _get_flow(self): ...
    unique_id: Incomplete
    expires: int
    def _setup(self) -> None: ...
    def _get_redis_key(self): ...
    def _get_redis_cred_storage(self): ...
    def _get_random_unique_id(self): ...
    def get_credentials(self): ...
    def delete_credentials(self) -> None: ...
    def get_http(self): ...
    def authorize(self, web) -> None: ...
    def ensure_authorized(self) -> None: ...
    def active(self) -> bool: ...
    def is_authorized(self) -> bool: ...

class RedisCredStorage(oauth2client.client.Storage):
    r: Incomplete
    key: Incomplete
    lockkey: Incomplete
    expires: Incomplete
    def __init__(self, key, lock, expires) -> None: ...
    def acquire_lock(self) -> None: ...
    def release_lock(self) -> None: ...
    def locked_get(self): ...
    def locked_put(self, credentials) -> None: ...
    def locked_delete(self) -> None: ...

def transform_json_variables(obj): ...
