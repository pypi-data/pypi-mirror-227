import threading
from _typeshed import Incomplete
from docassemble.base.error import DAException as DAException
from docassemble.base.util import DADict as DADict, DAList as DAList, DAObject as DAObject
from docassemble.webapp.backend import get_info_from_file_reference as get_info_from_file_reference
from docassemble.webapp.core.models import MachineLearning as MachineLearning
from docassemble.webapp.db_object import db as db
from docassemble.webapp.fixpickle import fix_pickle_obj as fix_pickle_obj

class MlLocal(threading.local):
    learners: Incomplete
    lastmodtime: Incomplete
    reset_counter: Incomplete
    def __init__(self) -> None: ...

ml_thread: Incomplete

class MachineLearningEntry(DAObject):
    dependent: Incomplete
    def classify(self, dependent: Incomplete | None = ...): ...
    def save(self): ...
    def predict(self, probabilities: bool = ...): ...

class MachineLearner:
    group_id: Incomplete
    initial_file: Incomplete
    reset_counter: int
    def __init__(self, *pargs, **kwargs) -> None: ...
    def reset(self) -> None: ...
    def _initialize(self, reset: bool = ...) -> None: ...
    def export_training_set(self, output_format: str = ..., key: Incomplete | None = ...): ...
    def dependent_in_use(self, key: Incomplete | None = ...): ...
    def is_empty(self): ...
    def start_from_file(self, fileref) -> None: ...
    def add_to_training_set(self, independent, dependent, key: Incomplete | None = ..., info: Incomplete | None = ...): ...
    def save_for_classification(self, indep, key: Incomplete | None = ..., info: Incomplete | None = ...): ...
    def retrieve_by_id(self, the_id): ...
    def one_unclassified_entry(self, key: Incomplete | None = ...): ...
    def new_entry(self, **kwargs): ...
    def unclassified_entries(self, key: Incomplete | None = ...): ...
    def classified_entries(self, key: Incomplete | None = ...): ...
    def _save_entry(self, **kwargs) -> None: ...
    def set_dependent_by_id(self, the_id, the_dependent) -> None: ...
    def delete_by_id(self, the_id) -> None: ...
    def delete_by_key(self, key) -> None: ...
    def save(self) -> None: ...
    def _train_from_db(self): ...
    def delete_training_set(self) -> None: ...
    def _train(self, indep, depend) -> None: ...
    def _predict(self, indep) -> None: ...

class SimpleTextMachineLearner(MachineLearner):
    def _learner(self): ...
    def _initialize(self, reset: bool = ...) -> None: ...
    def _train(self, indep, depend) -> None: ...
    def predict(self, indep, probabilities: bool = ...): ...
    def confusion_matrix(self, key: Incomplete | None = ..., output_format: Incomplete | None = ..., split: bool = ...): ...
    def delete_by_key(self, key): ...
    def classified_entries(self, key: Incomplete | None = ...): ...
    def unclassified_entries(self, key: Incomplete | None = ...): ...
    def one_unclassified_entry(self, key: Incomplete | None = ...): ...
    def save_for_classification(self, indep, key: Incomplete | None = ..., info: Incomplete | None = ...): ...
    def dependent_in_use(self, key: Incomplete | None = ...): ...

class SVMMachineLearner(SimpleTextMachineLearner):
    def _learner(self): ...

class RandomForestMachineLearner(MachineLearner):
    def _learner(self): ...
    def feature_importances(self): ...
    def _initialize(self, reset: bool = ...) -> None: ...
    def _train_from_db(self): ...
    def predict(self, indep, probabilities: bool = ...): ...
    def delete_by_key(self, key): ...
    def classified_entries(self, key: Incomplete | None = ...): ...
    def unclassified_entries(self, key: Incomplete | None = ...): ...
    def one_unclassified_entry(self, key: Incomplete | None = ...): ...
    def save_for_classification(self, indep, key: Incomplete | None = ..., info: Incomplete | None = ...): ...
    def add_to_training_set(self, independent, dependent, key: Incomplete | None = ..., info: Incomplete | None = ...): ...
    def dependent_in_use(self, key: Incomplete | None = ...): ...
    def export_training_set(self, output_format: str = ..., key: Incomplete | None = ...): ...

def process_independent_data(data): ...
