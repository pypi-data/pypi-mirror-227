# -*- coding: utf-8 -*-
"""ajuste_lineal.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_NI2uZ_qk3jrK9Yq3huqyeQRjuvIC66B
"""



import matplotlib.pyplot as plt #matplotlib contiene funciones necesarias para graficar. Los detalles se pueden consultar en https://matplotlib.org/stable/plot_types/index.html documentación
import numpy as np #numpy contiene las definiciones de las funciones matemáticas más comunes como trigonométricas, exponenciales, etc
from scipy.signal import find_peaks #contiene funciones de ajuste y minimización
import pandas as pd #funciones necesarias para manipular datos numéricos externos
from google.colab import drive
from scipy.optimize import curve_fit #https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.curve_fit.html

def ajuste_lineal(subset , powx , powy , titulo , xlabel , ylabel):
    #el módulo "ajuste_lineal" toma como parámetros el set de datos que pongamos en la primera entrada. Utiliza los valores powx , powy para reescalear los datos (si no fuese necesario, ingresar 0).
    #le pone título con titulo al gráfico y nombres a los ejes con xlabel ylabel.

    datos = subset
    x_data = np.array(datos["t^2"])
    y_data = np.array(datos["a^3"])
    errx = np.array(datos["errp^2"])
    erry = np.array(datos["errs^3"])

    #Reescalamos los valores

    x_data = np.array(x_data/pow(10,powx))
    y_data = np.array(y_data/pow(10,powy))
    errx = np.array(errx/pow(10,powx))
    erry = np.array(erry/pow(10,powy))

    #Conversion de datos a float64
    y_data = np.float64(y_data)
    x_data = np.float64(x_data)
    erry = np.float64(erry)
    errx = np.float64(errx)

    print("Periodo:",x_data)
    print("Semieje:",y_data)
    print("Incertezas en x:",errx)
    print("Incertezas en y:",erry)

    def model_f(x,m,b): #definimos la función a ajustar
        return m*x + b

    sig = np.absolute(erry) # En el array sig guardamos los errores en y (su valor absoluto) para pasar al ajuste

    popt, pcov = curve_fit(model_f, x_data , y_data , sigma = sig , absolute_sigma=True ) # Por defecto los valores iniciales con los que comienza el ajuste es 1, si queremos utilizar otros debemos agregar ,p0=[0.74,0.866,10,1.45]

# popt nos da un array con los parámetros de ajuste, en el orden que los pusimos en la función func (o sea, primero va a aparecer m y después b)
# pcov es la matriz de covarianza; en las líneas que siguen vamos a ver cómo obtener los errores de los parámetros de ajuste a partir de ésta

    print("Parámetros del ajuste:" , popt)

    perr = np.sqrt(np.diag(pcov)) # Obtenemos las incertezas del ajuste (también en el orden en que aparecen en la función) a partir de pcov
    print("Incertezas respectivas asociadas:",perr)

    print("Matriz de covarianza:" , pcov)

    print("m=", popt[0] , "+/-" , perr[0])

    print("b=", popt[1] , "+/-" , perr[1])

    #Grafiquemos la funcion ajustada y los puntos experimentales

    m_opt , b_opt = popt
    x_func = np.linspace(min(x_data) , max(x_data) , 100)
    y_func = model_f(x_func,m_opt,b_opt)

    plt.scatter(x_data,y_data , marker = '.')
    plt.errorbar(x_data,y_data,xerr=errx,yerr=erry,ecolor='g',fmt='none')
    plt.title(titulo, fontsize=12)
    plt.xlabel( xlabel , fontsize=16)
    plt.ylabel(ylabel , fontsize=16)

    plt.plot(x_func , y_func , c='r')

    plt.show()
    return()