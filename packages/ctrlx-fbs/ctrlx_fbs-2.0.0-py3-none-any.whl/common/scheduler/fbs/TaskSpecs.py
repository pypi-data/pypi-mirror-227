# automatically generated by the FlatBuffers compiler, do not modify

# namespace: fbs

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

# Task specifications to defined callable environment
class TaskSpecs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = TaskSpecs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsTaskSpecs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # TaskSpecs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Task name to link callables together within a task, e.g. "ctrlXAutomation" or "schedBackground"
    #   Allowed characters:
    #     Any alphanumeric character, beginning with a letter and a maximum length of 15 characters [a-zA-Z][a-zA-Z0-9]{1,15}
    # TaskSpecs
    def Name(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Task priority as well defined digit or range, e.g. "29" or "mid" to runs with medium priority
    #   Priority ranges:
    #       0 ..  10  : reserved for the system
    #      11 ..  99  : available for real-time user tasks
    #     100 .. 139  : available for non real-time user tasks
    #   Priority agreements:
    #      10         : reserved for Scheduler tick task 'schedMain'
    #      11         : highest prior real-time task, use of the policy FIFO policy
    #      23         : high prior real-time task, use of the policy FIFO policy
    #      29         : mid prior real-time task, use of the policy FIFO policy
    #      37         : low prior real-time task, use of the policy FIFO policy
    #      99         : lowest prior real-time task, use of the policy round-robin policy
    #     100         : highest prior non real-time task, use of the nice value of '-20'
    #     120         : common used non real-time task, use of the nice value of '0'
    #     139         : lowest prior non real-time task, use of the nice value of '19'
    #     high        : see (23), can be extended by operator '+' resp. '-' and in additional any digit offset, e.g. "high+1" results (24)
    #     mid         : see (29), can be extended by operator '+' resp. '-' and in additional any digit offset, e.g. "mid-2" results (27)
    #     low         : see (37), can be extended by operator '+' resp. '-' and in additional any digit offset, e.g. "low+3" results (40)
    #     nrt         : see (120), can be extended by operator '+' resp. '-' and in additional any digit offset, e.g. "nrt-10" results a nice value of (-10)
    # TaskSpecs
    def Priority(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Description of required task properties, e.g. "cyclic/ms/10" to runs cyclic every 10 millisecond
    # The notation of the task properties depends on supported task types.
    # Notation of cyclic tasks, separated by '/'
    #   event           : Execution event of the task ["cyclic"]
    #   cycle time unit : Supported units are millisecond ["ms"] and microsecond ["Âµs"]
    #   digit           : Any digit [0-9]+
    # TaskSpecs
    def Type(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

def TaskSpecsStart(builder): builder.StartObject(3)
def Start(builder):
    return TaskSpecsStart(builder)
def TaskSpecsAddName(builder, name): builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)
def AddName(builder, name):
    return TaskSpecsAddName(builder, name)
def TaskSpecsAddPriority(builder, priority): builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(priority), 0)
def AddPriority(builder, priority):
    return TaskSpecsAddPriority(builder, priority)
def TaskSpecsAddType(builder, type): builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(type), 0)
def AddType(builder, type):
    return TaskSpecsAddType(builder, type)
def TaskSpecsEnd(builder): return builder.EndObject()
def End(builder):
    return TaskSpecsEnd(builder)

class TaskSpecsT(object):

    # TaskSpecsT
    def __init__(self):
        self.name = None  # type: str
        self.priority = None  # type: str
        self.type = None  # type: str

    @classmethod
    def InitFromBuf(cls, buf, pos):
        taskSpecs = TaskSpecs()
        taskSpecs.Init(buf, pos)
        return cls.InitFromObj(taskSpecs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, taskSpecs):
        x = TaskSpecsT()
        x._UnPack(taskSpecs)
        return x

    def __eq__(self, other):
        return type(self) == type(other) and \
            self.name == other.name and \
            self.priority == other.priority and \
            self.type == other.type

    # TaskSpecsT
    def _UnPack(self, taskSpecs):
        if taskSpecs is None:
            return
        self.name = taskSpecs.Name()
        self.priority = taskSpecs.Priority()
        self.type = taskSpecs.Type()

    # TaskSpecsT
    def Pack(self, builder):
        if self.name is not None:
            name = builder.CreateString(self.name)
        if self.priority is not None:
            priority = builder.CreateString(self.priority)
        if self.type is not None:
            type = builder.CreateString(self.type)
        TaskSpecsStart(builder)
        if self.name is not None:
            TaskSpecsAddName(builder, name)
        if self.priority is not None:
            TaskSpecsAddPriority(builder, priority)
        if self.type is not None:
            TaskSpecsAddType(builder, type)
        taskSpecs = TaskSpecsEnd(builder)
        return taskSpecs
