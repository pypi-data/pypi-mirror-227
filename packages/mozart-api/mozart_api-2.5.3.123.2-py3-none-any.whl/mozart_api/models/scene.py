# coding: utf-8

"""
    Mozart platform API

    API for interacting with the Mozart platform.  # noqa: E501

    The version of the OpenAPI document: 0.2.0
    Contact: support@bang-olufsen.dk
    Generated by: https://openapi-generator.tech
"""


import pprint
import re  # noqa: F401

import six

from datetime import datetime
from typing import List, Dict, Literal, Optional

from mozart_api.models.action import Action

from mozart_api.configuration import Configuration


class Scene(object):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    """
    Attributes:
      openapi_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    openapi_types = {
        "action_list": "list[Action]",
        "client_context": "str",
        "label": "str",
        "tags": "list[str]",
        "classification": "str",
    }

    attribute_map = {
        "action_list": "actionList",
        "client_context": "clientContext",
        "label": "label",
        "tags": "tags",
        "classification": "classification",
    }

    def __init__(
        self,
        action_list: Optional[List[Action]] = None,
        client_context: Optional[str] = None,
        label: Optional[str] = None,
        tags: Optional[List[str]] = None,
        classification: Optional[str] = None,
        local_vars_configuration=None,
    ):  # noqa: E501
        """Scene - a model defined in OpenAPI"""  # noqa: E501
        if local_vars_configuration is None:
            local_vars_configuration = Configuration()
        self.local_vars_configuration = local_vars_configuration

        self._action_list = None
        self._client_context = None
        self._label = None
        self._tags = None
        self._classification = None
        self.discriminator = None

        self.action_list = action_list
        self.client_context = client_context
        self.label = label
        if tags is not None:
            self.tags = tags
        self.classification = classification

    @property
    def action_list(self):
        # type: () -> List[Action]
        """Gets the action_list of this Scene.  # noqa: E501

        An ordered list of Actions to run on the product  # noqa: E501

        :return: The action_list of this Scene.  # noqa: E501
        :rtype: List[Action]
        """
        return self._action_list

    @action_list.setter
    def action_list(self, action_list):
        # type: (list[Action]) -> None
        """Sets the action_list of this Scene.

        An ordered list of Actions to run on the product  # noqa: E501

        :param action_list: The action_list of this Scene.  # noqa: E501
        :type action_list: list[Action]
        :rtype: None
        """
        if (
            self.local_vars_configuration.client_side_validation and action_list is None
        ):  # noqa: E501
            raise ValueError(
                "Invalid value for `action_list`, must not be `None`"
            )  # noqa: E501

        self._action_list = action_list

    @property
    def client_context(self):
        # type: () -> str
        """Gets the client_context of this Scene.  # noqa: E501

        An optional generic string property supplied from the client. If supplied it will overwrite any currently stored clientContext. If not supplied any stored clientContext will be left unchanged.   # noqa: E501

        :return: The client_context of this Scene.  # noqa: E501
        :rtype: str
        """
        return self._client_context

    @client_context.setter
    def client_context(self, client_context):
        # type: (str) -> None
        """Sets the client_context of this Scene.

        An optional generic string property supplied from the client. If supplied it will overwrite any currently stored clientContext. If not supplied any stored clientContext will be left unchanged.   # noqa: E501

        :param client_context: The client_context of this Scene.  # noqa: E501
        :type client_context: str
        :rtype: None
        """
        if (
            self.local_vars_configuration.client_side_validation
            and client_context is not None
            and len(client_context) > 4096
        ):
            raise ValueError(
                "Invalid value for `client_context`, length must be less than or equal to `4096`"
            )  # noqa: E501

        self._client_context = client_context

    @property
    def label(self):
        # type: () -> str
        """Gets the label of this Scene.  # noqa: E501


        :return: The label of this Scene.  # noqa: E501
        :rtype: str
        """
        return self._label

    @label.setter
    def label(self, label):
        # type: (str) -> None
        """Sets the label of this Scene.


        :param label: The label of this Scene.  # noqa: E501
        :type label: str
        :rtype: None
        """

        self._label = label

    @property
    def tags(self):
        # type: () -> List[str]
        """Gets the tags of this Scene.  # noqa: E501

        A list of user defined tags. This allows a client to create virtual lists  # noqa: E501

        :return: The tags of this Scene.  # noqa: E501
        :rtype: List[str]
        """
        return self._tags

    @tags.setter
    def tags(self, tags):
        # type: (list[str]) -> None
        """Sets the tags of this Scene.

        A list of user defined tags. This allows a client to create virtual lists  # noqa: E501

        :param tags: The tags of this Scene.  # noqa: E501
        :type tags: list[str]
        :rtype: None
        """

        self._tags = tags

    @property
    def classification(self):
        # type: () -> str
        """Gets the classification of this Scene.  # noqa: E501

        The classification of Scene  # noqa: E501

        :return: The classification of this Scene.  # noqa: E501
        :rtype: str
        """
        return self._classification

    @classification.setter
    def classification(self, classification):
        # type: (str) -> None
        """Sets the classification of this Scene.

        The classification of Scene  # noqa: E501

        :param classification: The classification of this Scene.  # noqa: E501
        :type classification: str
        :rtype: None
        """
        allowed_values = [None, "system", "userDefined"]  # noqa: E501
        if (
            self.local_vars_configuration.client_side_validation
            and classification not in allowed_values
        ):  # noqa: E501
            raise ValueError(
                "Invalid value for `classification` ({0}), must be one of {1}".format(  # noqa: E501
                    classification, allowed_values
                )
            )

        self._classification = classification

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.openapi_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(
                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
                )
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(
                    map(
                        lambda item: (item[0], item[1].to_dict())
                        if hasattr(item[1], "to_dict")
                        else item,
                        value.items(),
                    )
                )
            else:
                result[attr] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, Scene):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, Scene):
            return True

        return self.to_dict() != other.to_dict()
