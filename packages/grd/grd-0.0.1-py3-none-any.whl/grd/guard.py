# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_guard.ipynb.

# %% auto 0
__all__ = ['Literals', 'TTypeGuardError', 'TTypeGuard']

# %% ../nbs/01_guard.ipynb 4
import inspect, typing, string

from dataclasses import dataclass
from typing import (
    Type, TypeVar, ClassVar, Any,  
    Literal, Optional, 
    List, Union, Iterable,
    get_args, get_origin
)

# %% ../nbs/01_guard.ipynb 5
from .ttype import TType, LiteralTType, UnionTType

# %% ../nbs/01_guard.ipynb 6
Literals = TypeVar('Literals')

# %% ../nbs/01_guard.ipynb 7
class TTypeGuardError(Exception):
    pass

# %% ../nbs/01_guard.ipynb 8
@dataclass
class TTypeGuard:
    types: ClassVar[Optional[Union[Iterable[Literals], Literals]]] = None

    @classmethod
    def isliteral(cls, val: Any) -> bool:
        return LiteralTType.istype(val)
    
    @classmethod
    def isiter(cls, val: Any):
        '''
        Check if the value is an iterable but not a Typing.Literal as we can't iterate over the
        arguments without calling get_args() which will raise an error if the value is not a Literal
        '''
        islit = cls.isliteral(val)
        isitr = isinstance(val, Iterable)
        return isitr and not isitr
  
    @classmethod
    def istype(cls, val: Any) -> bool: 
        '''Check if val is in types'''    
        if cls.types is None:
            return False

        types_iter = cls.types if cls.isiter(cls.types) else (cls.types, )
        for ttype in types_iter:
            return any(TType.checktype(ttype, val) for ttype in types_iter)
        return False

    @classmethod
    def check(cls, val: Any) -> bool:
        '''Alias for istype'''
        return cls.istype(val)

    @classmethod
    def guard(cls, val: Any) -> bool:
        '''Alias for istype'''
        return cls.istype(val)

    @classmethod
    def does_pass(cls, val: Any) -> bool:
        '''True if val passes istype'''
        return cls.istype(val) == True

    @classmethod
    def does_fail(cls, val: Any) -> bool:
        '''True if val fails istype'''
        return cls.istype(val) == False

    @classmethod
    def validate(cls, val: Any) -> Optional[TTypeGuardError]:
        if not cls.istype(val):
            raise TTypeGuardError(f'{val} not in {cls.types}')

    @classmethod
    def alarm(cls, val: Any) -> None:
        '''Alias for validate'''
        return cls.validate(val)

    @classmethod
    def block(cls, val: Any) -> None:
        '''Alias for validate'''
        return cls.alarm(value)

    def __call__(self, value: Any) -> bool:
        return self.istype(value)
