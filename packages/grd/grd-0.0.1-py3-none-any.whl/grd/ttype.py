# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_ttype.ipynb.

# %% auto 0
__all__ = ['TType', 'LiteralTType', 'UnionTType']

# %% ../nbs/00_ttype.ipynb 4
import inspect, typing, string
from abc import abstractmethod
from dataclasses import dataclass
from typing import (
    Type, ClassVar, Any,  
    Literal, Optional, 
    List, Union, 
    get_args, get_origin
)

# %% ../nbs/00_ttype.ipynb 6
@dataclass
class TType:
    ttype: ClassVar[Type] = Literal
    verbose: ClassVar[bool] = False
    
    def __init__(self):
        try:
            import typing
        except ImportError:
            pass
    
    @classmethod
    def get_dunder(cls, obj: object, attr: str, default: Optional[str] = '') -> str:
        dunder = f'__{attr}__'
        return getattr(obj, dunder, default)

    @classmethod
    def dunder_name(cls, obj: object, default: Optional[str] = '') -> str:
        return cls.get_dunder(obj, 'name', default)

    @classmethod
    def dunder_class(cls, obj: object, default: Optional[str] = None) -> str:
        return cls.get_dunder(obj, 'class', default)

    @classmethod
    def dunder_forward_arg(cls, obj: object, default: Optional[str] = None) -> str:
        return cls.get_dunder(obj, 'forward_arg', default)

    @classmethod
    def getattr_typing(cls, s: str = '') -> Any:        
        return getattr(typing, s, Any)

    @classmethod
    def is_typing(cls, a: Any, s: Optional[str] = '') -> bool:
        org = get_origin(a)
        atr = (s or cls.dunder_name(org, s))
        if cls.verbose: 
            tmpl = string.Template('\t\tis_typing(a=$a\t, s=$s)\t, org=$org\t, atr=$atr)')
            print(tmpl.substitute(a=a, s=s, org=org, atr=atr))            
        return org is cls.getattr_typing(atr)

    @classmethod
    def is_union(cls, a: Any) -> bool:
        return cls.is_typing(a, 'Union')

    @classmethod
    def is_tuple(cls, a: Any) -> bool:
        return cls.is_typing(a, 'Tuple')

    @classmethod
    def is_callable(cls, a: Any) -> bool:
        return cls.is_typing(a, 'Callable')

    @classmethod
    def is_literal(cls, a: Any) -> bool:
        return cls.is_typing(a, 'Literal')

    @classmethod
    def is_final(cls, a: Any) -> bool:
        return cls.is_typing(a, 'Final')

    @classmethod
    def is_classvar(cls, a: Any) -> bool:
        return cls.is_typing(a, 'ClassVar')

    @classmethod
    def is_annotated(cls, a: Any) -> bool:
        return cls.is_typing(a, 'Annotated')

    @classmethod
    def is_generic(cls, a: Any) -> bool:
        return cls.is_typing(a, 'Generic')
    
    @classmethod
    def is_list(cls, a: Any) -> bool:
        return get_origin(a) is list

    @classmethod
    def is_p(cls, a: Any) -> bool:
        return cls.is_typing(a, 'P')
    
    @classmethod
    def is_forwardref(cls, a: Any) -> bool:
        return cls.dunder_class(a) is cls.getattr_typing('ForwardRef')

    @classmethod
    def get_ttype_str(cls, ttype: Optional[Type] = None, camel_to_snake: Optional[bool] = False) -> str:
        '''Get the `is_{ttype}` string representation of the ttype.'''
        ttype = ttype or cls.ttype
        name = cls.dunder_name(ttype)
        _str = ''
        for char in name:
            if char.isupper() and len(_str):
                if camel_to_snake:
                    _str += f'_'
            else:
                _str += char.lower()
        attr = f'is_{_str}'
        return attr

    @classmethod
    def get_ttype_method(cls, ttype: Optional[Type] = None) -> Optional[str]:
        '''Get the class method  of the ttype.'''
        attr = cls.get_ttype_str(ttype)
        return getattr(cls, attr, None)

    @classmethod
    def is_ttype(cls, obj: Any, ttype: Optional[Type] = None) -> Union[Optional[bool], NotImplementedError]:
        '''Check if the object is of the ttype. If the ttype is not implemented, raise NotImplementedError.'''
        ttype = ((ttype or obj) or cls.ttype)
        func = cls.get_ttype_method(ttype)
        if func is None:
            raise NotImplementedError
        return func(obj)

    @classmethod
    @abstractmethod
    def istype(cls, a: Any) -> bool:
        '''Check if the object is of the `cls.ttype`.'''
        try:
            return cls.is_ttype(a, cls.ttype)
        except NotImplementedError:
            return False

    @classmethod
    def checktype(cls, typ: Type, val: Any):
        if cls.verbose: 
            print('checktyp(typ, val)', typ, val)
        tmpl = string.Template(f'\t$func(typ={typ}\t, val={val})')

        if cls.is_literal(typ):
            if cls.verbose: 
                print(tmpl.substitute(func='LITERAL'))
            return val in get_args(typ)

        elif cls.is_union(typ):
            if cls.verbose: 
                print(tmpl.substitute(func='UNION'))
            return any(cls.checktype(t, val) for t in get_args(typ))

        elif cls.is_forwardref(typ):
            if cls.verbose:
                print(tmpl.substitute(func='F_REF'))                
            return val in cls.dunder_forward_arg(typ)

        elif cls.is_ttype(typ, List):
            if cls.verbose: 
                print(tmpl.substitute(func='LIST'))
            return val in get_args(typ)
            
        else:
            try:
                return isinstance(val, typ)
            except TypeError:
                return False

# %% ../nbs/00_ttype.ipynb 14
@dataclass
class LiteralTType(TType):
    ttype: ClassVar[type] = Literal    
    @classmethod
    def istype(cls, val: Any) -> bool:
        return cls.is_literal(val)

# %% ../nbs/00_ttype.ipynb 16
@dataclass
class UnionTType(TType):
    ttype: ClassVar[type] = Union
    @classmethod
    def istype(cls, val: Any) -> bool:
        return cls.is_union(val)
