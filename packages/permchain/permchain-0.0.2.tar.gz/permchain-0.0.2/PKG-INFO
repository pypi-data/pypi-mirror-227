Metadata-Version: 2.1
Name: permchain
Version: 0.0.2
Summary: permchain
Home-page: https://www.github.com/langchain-ai/permchain
License: MIT
Requires-Python: >=3.8.1,<4.0
Classifier: License :: OSI Approved :: MIT License
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Requires-Dist: langchain (>=0.0.275,<0.0.276)
Project-URL: Repository, https://www.github.com/langchain-ai/permchain
Description-Content-Type: text/markdown

# `permchain`

## Get started

`pip install permchain`

## Usage

```python
from permchain import InMemoryPubSubConnection, PubSub, Topic

topic_one = Topic("one")
chain_one = Topic.IN.subscribe() | (lambda x: x + 'b') | topic_one.publish()
chain_two = topic_one.subscribe() | (lambda x: x + 'c') | Topic.OUT.publish()

conn = InMemoryPubSubConnection()
pubsub = PubSub(processes=(chain_one, chain_two), connection=conn)

assert pubsub.invoke('a') == ['abc']
```

Check `tests` and `examples` for more examples.

## Roadmap

- [ ] Add initial retry support (pending changes in `langchain`)
- [ ] Detect cycles (aka. infinite loops) and throw an error
  - [ ] Allow user to catch that error (by subcribing to an error topic?)
- [ ] Replace Queue data structure with a Log data structure (this will enable checking the status of the readers, etc.)
  - [ ] eg. https://anyio.readthedocs.io/en/3.x/streams.html
  - [ ] Implement IN and OUT topics as regular topics
- [ ] Enable resuming PubSub from the "middle" of the computation
- [ ] Add Redis-backed Connection implementation

