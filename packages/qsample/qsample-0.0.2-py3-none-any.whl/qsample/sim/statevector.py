# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/05c_sim.statevector.ipynb.

# %% auto 0
__all__ = ['MeasureResult', 'StatevectorSimulator']

# %% ../../nbs/05c_sim.statevector.ipynb 3
from .mixin import CircuitRunnerMixin
from projectq import MainEngine
import projectq.ops as ops

# %% ../../nbs/05c_sim.statevector.ipynb 4
class MeasureResult:
    """Class to hold measurement result
    
    Attributes
    ----------
    value : bool
        Outcome of measurement
    """
    def __init__(self, value: bool):
        self.value = bool(value)
        
    def __bool__(self):
        return self.value

# %% ../../nbs/05c_sim.statevector.ipynb 5
class StatevectorSimulator(CircuitRunnerMixin):
    """Statevector simulator using `ProjectQ` simulator
    
    Attributes
    ----------
    _n : int
        Number of qubits to simulate
    eng : ProjectQ.MainEngine
        ProjectQ simulator
    qureg : ProjectQ.QuantumRegister
        ProjectQ representation of quantum register
    qubits : dict
        Dictionary representation of quantum register
    """

    def __init__(self, num_qubits):
        """
        Parameters
        ----------
        num_qubits : int
            Number of qubits to simualate
        """
        self._n = num_qubits
        self.eng = MainEngine()
        self.qureg = self.eng.allocate_qureg(num_qubits)
        self.qubits = {i:qb for i,qb in enumerate(self.qureg)}
        
    def init(self, qubit: int) -> None:
        """Initialize to |0>"""
        outcome = self.measure(qubit)
        if outcome.value == 1:
            self.X(qubit)
    
    def measure(self, qubit: int) -> MeasureResult:
        """Measurement in Z basis"""
        q = self.qubits[qubit]
        self.eng.flush()
        ops.Measure | q
        self.eng.flush()
        return MeasureResult(value=int(q)) 
    
    def expectation(self, qubit: int) -> float:
        """Expectation value of measuring `qubit`
        
        Parameters
        ----------
        qubit : int
            Qubit of which expectation value is determined
        
        Returns
        -------
        float
            Expectation value of `qubit`
        """
        self.eng.flush()
        exp_op = ops.QubitOperator(f'Z{qubit}')
        exp = self.eng.backend.get_expectation_value(exp_op, self.qureg)
        ops.All(ops.Measure) | self.qureg # To avoid error message of deallocating qubits in a superposition
        return exp
        
    def I(self, qubit: int) -> None:
        """Identity gate"""
        pass
    
    def X(self, qubit: int) -> None:
        """X gate"""
        ops.X | self.qubits[qubit]
        
    def Y(self, qubit: int) -> None:
        """Y gate"""
        ops.Y | self.qubits[qubit]
        
    def Z(self, qubit: int) -> None:
        """Z gate"""
        ops.Z | self.qubits[qubit]
        
    def H(self, qubit: int) -> None:
        """H gate"""
        ops.H | self.qubits[qubit]
        
    def CNOT(self, control: int, target: int) -> None:
        """CNOT gate"""
        ops.CNOT | (self.qubits[control], self.qubits[target])
        
    def T(self, qubit: int) -> None:
        """T gate"""
        ops.T | self.qubits[qubit]
        
    def Td(self, qubit: int) -> None:
        """T^(dagger) gate"""
        ops.Tdagger | self.qubits[qubit]
        
    def S(self, qubit: int) -> None:
        """Phase gate"""
        ops.S | self.qubits[qubit]
        
    def Sd(self, qubit: int) -> None:
        """S^(dagger) gate"""
        ops.Sdagger | self.qubits[qubit]
        
    def Q(self, qubit: int) -> None:
        """Q gate"""
        ops.SqrtX | self.qubits[qubit]
        
    def Qd(self, qubit: int) -> None:
        """Q^(dagger) gate"""
        Qd = ops.get_inverse(ops.SqrtX)
        Qd | self.qubits[qubit]
    
    def Rx(self, qubit: int, angle: float) -> None:
        """X-rotation gate"""
        ops.Rx(angle) | self.qubits[qubit]
        
    def Ry(self, qubit: int, angle: float) -> None:
        """Y-rotation gate"""
        ops.Ry(angle) | self.qubits[qubit]
   
    def Rz(self, qubit: int, angle: float) -> None:
        """Z-rotation gate"""
        ops.Rz(angle) | self.qubits[qubit]
        
    def R(self, qubit: int) -> None:
        """R gate"""
        ops.R | self.qubits[qubit]
        
    def Rd(self, qubit: int) -> None:
        """R^(dagger) gate"""
        Rd = ops.get_inverse(ops.R)
        Rd | self.qubits[qubit]
        
    def MSd(self, qubitA: int, qubitB: int) -> None:
        """Molmer-Sorensen gate: -pi/2 XX rotation
        
        Reference
        ---------
            https://arxiv.org/pdf/2111.12654.pdf
        """
        self.Rd(qubitA)
        self.CNOT(qubitA, qubitB)
        self.R(qubitA)
        self.Qd(qubitA)
        self.Qd(qubitB)
        
    def __del__(self):
        self.eng.flush()
        ops.All(ops.Measure) | self.qureg # Required by ProjectQ
        
        try:
            self.eng.flush(deallocate_qubits=True)
        except KeyError:
            pass
